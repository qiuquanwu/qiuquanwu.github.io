---
layout: post
title: '使用node.js开发自己的加密货币-2'
subtitle: '也许是最后一篇'
date: 2018-05-06
categories: 技术
tags: 区块链 加密货币 node.js
---
# ＃2：工作证明
## 概观
#### 在本章中，我们将为玩具区块链版本实现一个简单的工作验证方案。在chapter1版本中，任何人都可以在没有成本的情况下为链条添加一个块。通过工作证明，我们引入了一个需要解决的计算难题，然后才能将块添加到区块链中。试图解决这个难题通常被称为“采矿”。
#### 通过工作证明，我们还可以控制区块链引入区块的频率（大约）。这是通过改变拼图的难度来完成的。如果地块经常被开采，拼图的难度将会增加，反之亦然。
#### 应该指出的是 ，本章我们还没有介绍交易。这意味着矿工实际上没有激励来产生一个区块。通常在加密货币中，矿工会因为找到一个块而获得奖励，但在我们的区块链中情况并非如此。
#### 本章中将要实现的完整代码可以在这里找到。
#### 困难，随机性和工作证明的难题
#### 我们将添加两个新的属性块结构：difficulty和nonce。要理解这些意义，我们首先必须介绍工作难题。
#### 工作证明的难题是找到一个块哈希，它有一个特定数量的零前缀。该difficulty属性定义块散列必须有多少前缀零，以使块有效。从哈希的二进制格式检查前缀零。
#### 下面是一些针对各种困难的有效和无效哈希的例子：
![image](https://lhartikk.github.io/assets/difficulty_examples.png)
#### 检查散列在难度上是否正确的代码：

```javascript
const hashMatchesDifficulty = (hash: string, difficulty: number): boolean => {
    const hashInBinary: string = hexToBinary(hash);
    const requiredPrefix: string = '0'.repeat(difficulty);
    return hashInBinary.startsWith(requiredPrefix);
};
 ```
####  为了找到满足难度的散列，我们必须能够为块的相同内容计算不同的散列。这是通过修改nonce参数来完成的。由于SHA256是一个散列函数，每当块中的任何内容发生变化，哈希将会完全不同。“挖掘”基本上只是尝试一个不同的随机数，直到块哈希匹配的困难。
#### 现在，difficulty和nonce添加，块结构如下所示：

```javascript
class Block {

    public index: number;
    public hash: string;
    public previousHash: string;
    public timestamp: number;
    public data: string;
    public difficulty: number;
    public nonce: number;

    constructor(index: number, hash: string, previousHash: string,
                timestamp: number, data: string, difficulty: number, nonce: number) {
        this.index = index;
        this.previousHash = previousHash;
        this.timestamp = timestamp;
        this.data = data;
        this.hash = hash;
        this.difficulty = difficulty;
        this.nonce = nonce;
    }
}
```
#### 
#### 我们还必须记得更新创世区块！
## 找到一个块
#### #### 如上所述，为了找到一个有效的块散列，我们必须增加nonce，直到我们得到一个有效的散列。找到一个令人满意的散列是完全随机的过程。我们必须通过足够的随机循环，直到找到一个令人满意的哈希为止：

```javascript
const findBlock = (index: number, previousHash: string, timestamp: number, data: string, difficulty: number): Block => {
    let nonce = 0;
    while (true) {
        const hash: string = calculateHash(index, previousHash, timestamp, data, difficulty, nonce);
        if (hashMatchesDifficulty(hash, difficulty)) {
            return new Block(index, hash, previousHash, timestamp, data, difficulty, nonce);
        }
        nonce++;
    }
};
```

#### 当找到该块时，就像第1章中的情况那样将其广播到网络。
## 对困难达成共识
#### 我们现在有办法查找和验证给定难度的散列，但难度是如何确定的？节点必须有一种方法来同意目前的困难。为此，我们引入一些新的规则来计算当前 的网络难度。
#### 让我们为网络定义以下新的常量：
#### ==BLOCK_GENERATION_INTERVA==L定义了块应该被发现的频率。（在比特币中这个值是10分钟）
#### ==DIFFICULTY_ADJUSTMENT_INTERVAL==定义了难度应该随着网络散列率的增加或减少而调整的频率。（在比特币中，这个值是2016年的块）
#### 我们将块生成时间间隔设置为10秒，难度调整为10个块。这些常数不会随着时间的推移而变化，而且是硬编码的。

```javascript
// in seconds
const BLOCK_GENERATION_INTERVAL: number = 10;

// in blocks
const DIFFICULTY_ADJUSTMENT_INTERVAL: number = 10;
```

#### 现在我们有办法就这个区块的困难达成一致。对于每10个生成的块，我们检查生成这些块的时间是大于还是小于预期的时间。预期的时间计算如下：BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL。预期时间表示哈希率与当前难度完全匹配的情况。
#### 如果所花费的时间至少比预期难度大两倍或更少，我们可以增加或减少一个难度。难度调整由以下代码处理：

```javascript
const getDifficulty = (aBlockchain: Block[]): number => {
    const latestBlock: Block = aBlockchain[blockchain.length - 1];
    if (latestBlock.index % DIFFICULTY_ADJUSTMENT_INTERVAL === 0 && latestBlock.index !== 0) {
        return getAdjustedDifficulty(latestBlock, aBlockchain);
    } else {
        return latestBlock.difficulty;
    }
};

const getAdjustedDifficulty = (latestBlock: Block, aBlockchain: Block[]) => {
    const prevAdjustmentBlock: Block = aBlockchain[blockchain.length - DIFFICULTY_ADJUSTMENT_INTERVAL];
    const timeExpected: number = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;
    const timeTaken: number = latestBlock.timestamp - prevAdjustmentBlock.timestamp;
    if (timeTaken < timeExpected / 2) {
        return prevAdjustmentBlock.difficulty + 1;
    } else if (timeTaken > timeExpected * 2) {
        return prevAdjustmentBlock.difficulty - 1;
    } else {
        return prevAdjustmentBlock.difficulty;
    }
};
```
## 时间戳验证
#### 在chapter1版本的区块链中，时间戳没有任何作用也没有验证。事实上，这可能是客户决定产生的任何东西。现在这个变化是因为timeTaken变量（在前面的代码片段中）是根据块的时间戳来计算的，所以引入了难度调整。
#### 为了减轻引入虚假时间戳的攻击，以便处理难度，引入了以下规则：
#### 如果时间戳从我们感知的时间起最多不超过1分钟，则块是有效的。
#### 如果时间戳在前一个块的过去最多1分钟，则链中的块是有效的。

```javascript
const isValidTimestamp = (newBlock: Block, previousBlock: Block): boolean => {
    return ( previousBlock.timestamp - 60 < newBlock.timestamp )
        && newBlock.timestamp - 60 < getCurrentTimestamp();
};
```

## 累积困难
#### 在区块链的chapter1版本中，我们总是选择“最长”的区块链是有效的。现在必须改变困难。对于现在的“正确”链条不是“最长”的链条，而是累积难度最大的链条。换句话说，正确的链是需要最多资源（= hashRate * time）来产生的链。
#### 为了得到连锁的累积难度，我们计算2\^difficulty每个街区，并把所有这些数字的总和。我们必须使用2^difficulty正如我们选择难度来表示必须在二进制格式前缀散列的零的数量。例如，如果比较5和11的困难，则需要2 ^（11-5）= 2 ^ 6倍的工作才能找到后一个困难的块。
#### 在下面的例子中，“链B”是“正确的”链，虽然它有发烧块：
![image](https://lhartikk.github.io/assets/Cumulative_difficulties.png)
#### 只有块的难度很重要，而不是实际的散列（假设散列是有效的）。例如，如果难度是4，并且块散列是000000a34c ...（=也满足6的难度），则在计算累积难度时仅考虑4的难度。
#### 这个属性也被称为“Nakamoto共识”，这是Satoshi在发明比特币时最重要的发明之一。在叉子的情况下，矿工必须选择他们决定把他们当前的资源（= hashRate）哪个链。由于矿工的利益是要生产这种区块链中的矿块，矿工们最终会选择同样的链条。
## 结论
#### 工作难题难题必须具备的一个重要特征是难以解决，但易于验证。找到具体的SHA256散列是这样一个问题的一个很好和简单的例子。
#### 我们实现了难度方面，节点现在必须“挖掘”，以添加新的块链。在下一章我们将实现交易。
#### 本章的完整代码可以在[这里](https://github.com/lhartikk/naivecoin/tree/chapter2)找到。